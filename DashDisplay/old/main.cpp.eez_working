/*
  LovyanGFX + LVGL + EEZ (UI-only) robust skeleton
  - C/C++ linkage fixed for EEZ C sources
  - Blocking flush to avoid DMA timing issues
  - 5ms LVGL tick timer
  - Child inspection + overlay probe label
*/

#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>

// #define EEZ_FOR_LVGL
#define EEZ_UI_MAIN_SYMBOL SCREEN_ID_MAIN   // <-- CHANGE to your actual symbol if needed

#include <lvgl.h>

// EEZ headers are typically C. Ensure C linkage in C++ TU:
#ifdef __cplusplus
extern "C" {
#endif
#include "ui.h"
#include "screens.h"
#ifdef __cplusplus
}
#endif

#define GFX_BL  2   // Backlight pin

#define LGFX_USE_V1
#include <LovyanGFX.hpp>
#include <lgfx/v1/platforms/esp32s3/Panel_RGB.hpp>
#include <lgfx/v1/platforms/esp32s3/Bus_RGB.hpp>

// ──────────────────────────────────────────────────────────────
// LovyanGFX display for ESP32-S3 RGB panel (800x480)
// ──────────────────────────────────────────────────────────────
class LGFX : public lgfx::LGFX_Device {
public:
  lgfx::Bus_RGB     _bus_instance;
  lgfx::Panel_RGB   _panel_instance;

  LGFX(void) {
    { // Bus config
      auto cfg = _bus_instance.config();
      cfg.panel = &_panel_instance;

      // RGB data pins
      cfg.pin_d0  = GPIO_NUM_15; // B0
      cfg.pin_d1  = GPIO_NUM_7;  // B1
      cfg.pin_d2  = GPIO_NUM_6;  // B2
      cfg.pin_d3  = GPIO_NUM_5;  // B3
      cfg.pin_d4  = GPIO_NUM_4;  // B4

      cfg.pin_d5  = GPIO_NUM_9;  // G0
      cfg.pin_d6  = GPIO_NUM_46; // G1
      cfg.pin_d7  = GPIO_NUM_3;  // G2
      cfg.pin_d8  = GPIO_NUM_8;  // G3
      cfg.pin_d9  = GPIO_NUM_16; // G4
      cfg.pin_d10 = GPIO_NUM_1;  // G5

      cfg.pin_d11 = GPIO_NUM_14; // R0
      cfg.pin_d12 = GPIO_NUM_21; // R1
      cfg.pin_d13 = GPIO_NUM_47; // R2
      cfg.pin_d14 = GPIO_NUM_48; // R3
      cfg.pin_d15 = GPIO_NUM_45; // R4

      // Sync pins
      cfg.pin_henable = GPIO_NUM_41;
      cfg.pin_vsync   = GPIO_NUM_40;
      cfg.pin_hsync   = GPIO_NUM_39;
      cfg.pin_pclk    = GPIO_NUM_0;
      cfg.freq_write  = 15000000;

      // Timings (tweak for your panel if needed)
      cfg.hsync_polarity    = 0;
      cfg.hsync_front_porch = 40;
      cfg.hsync_pulse_width = 48;
      cfg.hsync_back_porch  = 40;

      cfg.vsync_polarity    = 0;
      cfg.vsync_front_porch = 1;
      cfg.vsync_pulse_width = 31;
      cfg.vsync_back_porch  = 13;

      cfg.pclk_active_neg   = 1;
      cfg.de_idle_high      = 0;
      cfg.pclk_idle_high    = 0;

      _bus_instance.config(cfg);
    }

    { // Panel config
      auto cfg = _panel_instance.config();
      cfg.memory_width  = 800;
      cfg.memory_height = 480;
      cfg.panel_width   = 800;
      cfg.panel_height  = 480;
      cfg.offset_x      = 0;
      cfg.offset_y      = 0;
      _panel_instance.config(cfg);
    }

    _panel_instance.setBus(&_bus_instance);
    setPanel(&_panel_instance);
  }
};

LGFX lcd;

// ──────────────────────────────────────────────────────────────
// LVGL display driver
// ──────────────────────────────────────────────────────────────
static uint32_t screenWidth;
static uint32_t screenHeight;
static lv_disp_draw_buf_t draw_buf;
static lv_color_t disp_draw_buf[800 * 480 / 10];
static lv_disp_drv_t disp_drv;

// Blocking flush (avoids DMA race). Once this works, you can switch to DMA.
static void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
  uint32_t w = (area->x2 - area->x1 + 1);
  uint32_t h = (area->y2 - area->y1 + 1);
  lcd.pushImageDMA(area->x1, area->y1, w, h, (lgfx::rgb565_t*)&color_p->full);
  lv_disp_flush_ready(disp);   // return right away for async DMA
}


// ──────────────────────────────────────────────────────────────
// LVGL tick @ 5ms (needed for timers/animations/invalidations)
// ──────────────────────────────────────────────────────────────
static hw_timer_t * lv_tick_timer = nullptr;
static void IRAM_ATTR onLvglTick() {
  lv_tick_inc(10);
}

// ──────────────────────────────────────────────────────────────
// Helpers
// ──────────────────────────────────────────────────────────────
static void inspect_active_screen() {
  lv_obj_t *scr = lv_scr_act();
  uint32_t cnt = lv_obj_get_child_cnt(scr);
  Serial.printf("EEZ/LVGL: active screen children = %u\n", (unsigned)cnt);
  for (uint32_t i = 0; i < cnt; i++) {
    lv_obj_t *c = lv_obj_get_child(scr, i);
    Serial.printf("  [%u] hidden=%d opa=%u w=%d h=%d\n", i,
      lv_obj_has_flag(c, LV_OBJ_FLAG_HIDDEN),
      (unsigned)lv_obj_get_style_opa(c, 0),
      (int)lv_obj_get_width(c),
      (int)lv_obj_get_height(c));
  }
}

static void overlay_probe_label(const char *txt) {
  lv_obj_t *lbl = lv_label_create(lv_scr_act());
  lv_label_set_text(lbl, txt);
  lv_obj_center(lbl);
}

static void load_eez_screen() {
  ui_init();   // create EEZ objects

  // If your export provided a loader function instead of a symbol, use that:
  //   ui_load_main_screen();
  // Otherwise, load the symbol:
  // lv_scr_load(EEZ_UI_MAIN_SYMBOL);

  inspect_active_screen();
  overlay_probe_label("LVGL alive (probe)");
}

// ──────────────────────────────────────────────────────────────
// SETUP / LOOP
// ──────────────────────────────────────────────────────────────
void setup() {
  Serial.begin(115200);
  Serial.println("Start: LVGL + EEZ (UI-only)");

  lcd.begin();
  pinMode(GFX_BL, OUTPUT);
  digitalWrite(GFX_BL, HIGH);

  lv_init();

  screenWidth  = lcd.width();
  screenHeight = lcd.height();
  Serial.printf("Screen: %ux%u\n", (unsigned)screenWidth, (unsigned)screenHeight);

  lv_disp_draw_buf_init(&draw_buf, disp_draw_buf, NULL, (screenWidth * screenHeight) / 10);
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res  = screenWidth;
  disp_drv.ver_res  = screenHeight;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);

  // 5ms LVGL tick (hardware timer; more reliable than ad-hoc delays)
  lv_tick_timer = timerBegin(0, 80, true); // 80 MHz / 80 = 1 MHz tick
  timerAttachInterrupt(lv_tick_timer, &onLvglTick, true);
  timerAlarmWrite(lv_tick_timer, 5000, true); // 5000 us = 5 ms
  timerAlarmEnable(lv_tick_timer);

  delay(200);
  load_eez_screen();

  // Optional: keep one resource symbol alive to defeat dead-stripping
  // extern const lv_img_dsc_t ui_img_logo_png;
  // (void)&ui_img_logo_png;
}

void loop() {
  lv_timer_handler();
  // delay(5);
}
